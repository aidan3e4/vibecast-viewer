<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibecast Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .header {
            background: #16213e;
            padding: 20px 30px;
            border-bottom: 1px solid #0f3460;
        }

        .header h1 {
            color: #e94560;
            font-size: 1.8em;
        }

        .header p {
            color: #888;
            margin-top: 5px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background: #16213e;
            border-bottom: 2px solid #0f3460;
        }

        .tab {
            padding: 15px 30px;
            cursor: pointer;
            color: #888;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 500;
        }

        .tab:hover {
            color: #ccc;
            background: rgba(233, 69, 96, 0.1);
        }

        .tab.active {
            color: #e94560;
            border-bottom-color: #e94560;
        }

        .tab-content {
            display: none;
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Panels */
        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #0f3460;
        }

        .panel h2 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .panel h3 {
            color: #ddd;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        /* Form elements */
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: flex-end;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
            font-size: 0.9em;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            background: #0f3460;
            border: 1px solid #1a4a8a;
            border-radius: 4px;
            color: #eee;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #e94560;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #e94560;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #d63651;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #45a049;
        }

        .btn-secondary {
            background: #0f3460;
            color: #ddd;
            border: 1px solid #1a4a8a;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #1a4a8a;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Stats */
        .stats-row {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px 20px;
            border-radius: 8px;
            text-align: center;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #e94560;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
            margin-top: 5px;
        }

        /* Image grid */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .image-card {
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            position: relative;
        }

        .image-card:hover {
            border-color: #e94560;
            transform: translateY(-2px);
        }

        .image-card.has-selection {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .image-card .selection-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .image-card img {
            width: 100%;
            aspect-ratio: 4/3;
            object-fit: cover;
        }

        .image-card .info {
            padding: 12px;
        }

        .image-card .filename {
            font-weight: 500;
            color: #ddd;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-card .time {
            color: #888;
            font-size: 0.8em;
            margin-top: 4px;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            overflow-y: auto;
            padding: 40px 20px;
        }

        .modal-overlay.show {
            display: block;
        }

        .modal-content {
            max-width: 1400px;
            margin: 0 auto;
            background: #16213e;
            border-radius: 12px;
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #0f3460;
        }

        .modal-header h3 {
            color: #e94560;
            flex: 1;
        }

        .modal-nav {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-right: 20px;
        }

        .image-counter {
            color: #888;
            font-size: 0.85em;
            margin: 0 10px;
            white-space: nowrap;
        }

        .nav-arrow {
            background: #0f3460;
            border: 1px solid #1a4a8a;
            color: #ddd;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .nav-arrow:hover:not(:disabled) {
            background: #1a4a8a;
            color: #e94560;
        }

        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            padding: 0 10px;
        }

        .modal-close:hover {
            color: #e94560;
        }

        .modal-body {
            padding: 25px;
        }

        /* Unwarped grid */
        .unwarped-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .unwarped-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .unwarped-grid {
                grid-template-columns: 1fr;
            }
        }

        .unwarped-item {
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .unwarped-item.not-available {
            opacity: 0.5;
        }

        .unwarped-item.fisheye {
            background: #1a2e4a;
            border: 2px solid #e94560;
        }

        .unwarped-item.selected {
            border: 2px solid #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .unwarped-item .direction {
            padding: 10px 15px;
            background: #1a4a8a;
            font-weight: 500;
            text-transform: capitalize;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .unwarped-item.fisheye .direction {
            background: #e94560;
            color: white;
        }

        .unwarped-item.selected .direction {
            background: #4CAF50;
            color: white;
        }

        .unwarped-item img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: cover;
            aspect-ratio: 4/3;
        }

        .unwarped-item .not-found {
            padding: 40px;
            text-align: center;
            color: #666;
        }

        .selection-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        .selection-toggle-btn {
            background: #0f3460;
            border: 1px solid #1a4a8a;
            color: #ddd;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selection-toggle-btn:hover {
            background: #1a4a8a;
        }

        .selection-toggle-btn.selected {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }

        .selection-toggle-btn .checkmark {
            font-size: 16px;
        }

        /* Processing */
        .process-form {
            max-width: 800px;
        }

        .selected-image-preview {
            margin: 20px 0;
            display: none;
        }

        .selected-image-preview img {
            max-width: 400px;
            border-radius: 8px;
        }

        .processing-status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .processing-status.loading {
            display: block;
            background: #0f3460;
            color: #888;
        }

        .processing-status.success {
            display: block;
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .processing-status.error {
            display: block;
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        /* Results */
        .results-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .result-card {
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
        }

        .result-header {
            padding: 15px 20px;
            background: #1a4a8a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .result-header:hover {
            background: #234a8a;
        }

        .result-body {
            padding: 20px;
            display: none;
        }

        .result-body.show {
            display: block;
        }

        .result-images {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .result-image-item {
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
        }

        .result-image-item img {
            width: 100%;
        }

        .result-image-item .analysis {
            padding: 15px;
        }

        .analysis-field {
            margin-bottom: 10px;
        }

        .analysis-field .label {
            color: #888;
            font-size: 0.85em;
            text-transform: uppercase;
        }

        .analysis-field .value {
            color: #ddd;
            margin-top: 4px;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #444;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Fullscreen image viewer */
        .fullscreen-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            cursor: zoom-out;
        }

        .fullscreen-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-container {
            position: relative;
            max-width: 95%;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .fullscreen-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .fullscreen-nav-btn {
            background: #0f3460;
            border: 1px solid #1a4a8a;
            color: #ddd;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .fullscreen-nav-btn:hover:not(:disabled) {
            background: #1a4a8a;
            color: #e94560;
        }

        .fullscreen-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .fullscreen-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .fullscreen-counter {
            color: #888;
            font-size: 0.85em;
        }

        .fullscreen-label {
            color: #e94560;
            font-weight: 600;
            font-size: 1.1em;
            text-transform: capitalize;
        }

        .fullscreen-overlay img {
            max-width: 90vw;
            max-height: 75vh;
            object-fit: contain;
            cursor: default;
        }

        .fullscreen-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid #1a4a8a;
            color: #888;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .fullscreen-close:hover {
            color: #e94560;
            border-color: #e94560;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        /* Error banner */
        .error-banner {
            background: rgba(244, 67, 54, 0.15);
            border: 1px solid rgba(244, 67, 54, 0.5);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #f44336;
        }

        .error-banner strong {
            display: block;
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .error-banner pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            white-space: pre-wrap;
            font-size: 0.9em;
            color: #ffcdd2;
        }

        /* Date range selector */
        .date-range-selector {
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .date-range-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .date-range-header:hover {
            background: #1a4a8a;
        }

        .date-range-header .summary {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .date-range-header .summary-icon {
            color: #e94560;
            font-size: 1.2em;
        }

        .date-range-header .summary-text {
            color: #ddd;
        }

        .date-range-header .summary-text .highlight {
            color: #e94560;
            font-weight: 600;
        }

        .date-range-header .toggle-icon {
            color: #888;
            transition: transform 0.2s;
        }

        .date-range-selector.open .toggle-icon {
            transform: rotate(180deg);
        }

        .date-range-body {
            display: none;
            padding: 20px;
            border-top: 1px solid #1a4a8a;
            background: #0a2a4a;
        }

        .date-range-selector.open .date-range-body {
            display: block;
        }

        .date-time-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .date-time-group {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
        }

        .date-time-group h4 {
            color: #e94560;
            margin-bottom: 12px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .date-time-inputs {
            display: flex;
            gap: 10px;
        }

        .date-time-inputs .form-group {
            flex: 1;
        }

        .date-range-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }

        .quick-select {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .quick-select-btn {
            padding: 6px 12px;
            background: #16213e;
            border: 1px solid #1a4a8a;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .quick-select-btn:hover {
            background: #1a4a8a;
            color: #ddd;
        }

        .quick-select-btn.active {
            background: #e94560;
            border-color: #e94560;
            color: white;
        }

        .input-clickable {
            cursor: pointer;
        }

        .input-clickable:hover input {
            border-color: #e94560;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Vibecast Viewer</h1>
        <p>Explore, process, and analyze fisheye images from S3</p>
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="explorer">Image Explorer</div>
        <div class="tab" data-tab="process">Process Images</div>
        <div class="tab" data-tab="results">Result Explorer</div>
    </div>

    <!-- Tab 1: Raw Image Explorer -->
    <div id="explorer" class="tab-content active">
        <!-- Error banner (hidden by default, shown when there are credential issues) -->
        <div id="credentialError" class="error-banner" style="display: none;">
            <strong>⚠ AWS Credentials Not Configured</strong>
            <p id="credentialErrorMessage"></p>
        </div>

        <div class="panel">
            <h2>Image Distribution</h2>
            <div class="stats-row" id="globalStats">
                <div class="stat-box">
                    <div class="stat-value" id="totalImages">-</div>
                    <div class="stat-label">Total Images</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="totalDays">-</div>
                    <div class="stat-label">Days with Photos</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="dateRange">-</div>
                    <div class="stat-label">Date Range</div>
                </div>
            </div>
            <div id="histogramContainer" style="margin-top: 20px;">
                <canvas id="histogram" height="200"></canvas>
            </div>
        </div>

        <div class="panel">
            <h2>Browse Images - Select Date & Time Range</h2>

            <!-- Date Range Selector -->
            <div class="date-range-selector" id="dateRangeSelector">
                <div class="date-range-header" onclick="openDateSelector()">
                    <div class="summary">
                        <span class="summary-icon">&#128197;</span>
                        <span class="summary-text" id="dateRangeSummary">
                            <span class="highlight" id="summaryFrom">{{ default_date }}</span>
                            <span style="color: #666;"> to </span>
                            <span class="highlight" id="summaryTo">{{ default_date }}</span>
                            <span style="color: #666; margin-left: 10px;">|</span>
                            <span style="color: #888; margin-left: 10px;" id="summaryTime">00:00 - 23:59</span>
                        </span>
                    </div>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="date-range-body">
                    <div class="date-time-row">
                        <div class="date-time-group">
                            <h4>From</h4>
                            <div class="date-time-inputs">
                                <div class="form-group input-clickable" onclick="this.querySelector('input').showPicker()">
                                    <label>Date</label>
                                    <input type="date" id="fromDate" value="{{ default_date }}" onchange="updateDateSummary()">
                                </div>
                                <div class="form-group input-clickable" onclick="this.querySelector('input').showPicker()">
                                    <label>Time</label>
                                    <input type="time" id="fromTime" value="00:00" onchange="updateDateSummary()">
                                </div>
                            </div>
                        </div>
                        <div class="date-time-group">
                            <h4>To</h4>
                            <div class="date-time-inputs">
                                <div class="form-group input-clickable" onclick="this.querySelector('input').showPicker()">
                                    <label>Date</label>
                                    <input type="date" id="toDate" value="{{ default_date }}" onchange="updateDateSummary()">
                                </div>
                                <div class="form-group input-clickable" onclick="this.querySelector('input').showPicker()">
                                    <label>Time</label>
                                    <input type="time" id="toTime" value="23:59" onchange="updateDateSummary()">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="quick-select">
                        <span style="color: #888; font-size: 0.85em; margin-right: 8px;">Quick select:</span>
                        <button class="quick-select-btn" onclick="quickSelect('today')">Today</button>
                        <button class="quick-select-btn" onclick="quickSelect('yesterday')">Yesterday</button>
                        <button class="quick-select-btn" onclick="quickSelect('week')">Last 7 days</button>
                        <button class="quick-select-btn" onclick="quickSelect('month')">Last 30 days</button>
                        <button class="quick-select-btn" onclick="quickSelect('morning')">Morning (6-12)</button>
                        <button class="quick-select-btn" onclick="quickSelect('afternoon')">Afternoon (12-18)</button>
                        <button class="quick-select-btn" onclick="quickSelect('evening')">Evening (18-24)</button>
                    </div>

                    <div class="date-range-actions">
                        <button class="btn btn-secondary" onclick="resetDateRange()">Reset</button>
                        <button class="btn btn-primary" onclick="loadImagesForRange()">Load Images</button>
                    </div>
                </div>
            </div>

            <div id="imageGridContainer">
                <div class="stats-row" id="dayStats" style="display: none;">
                    <div class="stat-box">
                        <div class="stat-value" id="dayImageCount">0</div>
                        <div class="stat-label">Captured images in range</div>
                        <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px; justify-content: center;">
                            <input type="checkbox" id="autoUnwarpCheckbox" style="width: auto; cursor: pointer; margin: 0;">
                            <label for="autoUnwarpCheckbox" style="color: #aaa; cursor: pointer; margin: 0; font-size: 0.85em;">
                                Auto-unwarp images
                            </label>
                        </div>
                    </div>
                    <div class="stat-box" id="selectedImageCount">
                        <div class="stat-value" style="color: #4CAF50;" id="selectedImageCountValue">0</div>
                        <div class="stat-label">Unwarped images selected for processing</div>
                        <button class="btn btn-success" id="processImageBtn" onclick="goToProcessTab()" disabled title="Select an image to process first" style="margin-top: 12px; padding: 8px 16px; font-size: 0.9em;">
                            Process Images
                        </button>
                    </div>
                </div>
                <div class="image-grid" id="imageGrid"></div>
            </div>
        </div>
    </div>

    <!-- Tab 2: Process Images -->
    <div id="process" class="tab-content">
        <div class="panel">
            <h2>Process Selected Images</h2>
            <p id="processTabHelp" style="color: #888; margin-bottom: 20px;">Select images from the Image Explorer tab, then return here to process them.</p>

            <div id="selectedImagesContainer">
                <div class="stats-row" style="margin-bottom: 20px;">
                    <div class="stat-box">
                        <div class="stat-value" style="color: #4CAF50;" id="processSelectedCount">0</div>
                        <div class="stat-label">Images Selected</div>
                    </div>
                </div>

                <div id="selectedImagesGrid" class="unwarped-grid" style="margin-bottom: 30px;">
                    <div class="empty-state">
                        <p style="color: #666;">No images selected yet.</p>
                        <p style="color: #888; font-size: 0.9em; margin-top: 10px;">Go to the Image Explorer tab and select unwarped images to process.</p>
                    </div>
                </div>
            </div>

            <div class="process-form" style="max-width: 100%;">
                <div class="form-group">
                    <label for="processModel">Model</label>
                    <select id="processModel">
                        <option value="">Loading models...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Prompt Template</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <select id="promptName" style="flex: 2;" onchange="onPromptNameChange()">
                            <option value="">Loading prompts...</option>
                        </select>
                        <select id="promptVersion" style="flex: 1;" onchange="onPromptVersionChange()">
                            <option value="">-</option>
                        </select>
                    </div>
                    <div id="newPromptRow" style="display: none; margin-bottom: 10px;">
                        <input type="text" id="newPromptName" placeholder="Enter new prompt name..." style="width: 100%; padding: 8px; background: #0f3460; border: 1px solid #1a4a8a; border-radius: 4px; color: #fff;">
                    </div>
                    <textarea id="processPrompt" rows="4" placeholder="Enter a custom prompt for the analysis..."></textarea>
                    <div style="margin-top: 10px; text-align: right;">
                        <button class="btn btn-secondary" id="savePromptBtn" onclick="savePrompt()" style="padding: 8px 16px;">
                            Push new version
                        </button>
                    </div>
                </div>

                <button class="btn btn-primary" id="processBtn" onclick="processSelectedImages()" disabled>
                    Process All Selected Images
                </button>

                <div class="processing-status" id="processStatus"></div>
            </div>
        </div>
    </div>

    <!-- Tab 3: Result Explorer -->
    <div id="results" class="tab-content">
        <div class="panel">
            <h2>Result Distribution</h2>
            <div class="stats-row">
                <div class="stat-box">
                    <div class="stat-value" id="totalResults">-</div>
                    <div class="stat-label">Total Results</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="totalImagesAnalyzed">-</div>
                    <div class="stat-label">Images Analyzed</div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="color: #e94560; font-size: 1em; margin: 0;">Results Generated</h3>
                        <div id="processedDateFilter" style="display: none; background: #0a2a4a; padding: 4px 8px; border-radius: 4px; font-size: 0.85em;">
                            <span style="color: #aaa;">Filter: </span>
                            <span id="processedDateFilterValue" style="color: #e94560;"></span>
                            <button onclick="clearProcessedDateFilter()" style="background: none; border: none; color: #888; margin-left: 6px; cursor: pointer; font-size: 1.1em;" title="Clear filter">×</button>
                        </div>
                    </div>
                    <div style="height: 150px;">
                        <canvas id="resultsGeneratedHistogram"></canvas>
                    </div>
                </div>
                <div>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="color: #e94560; font-size: 1em; margin: 0;">Images Analyzed (by capture date)</h3>
                        <div id="captureDateFilter" style="display: none; background: #0a2a4a; padding: 4px 8px; border-radius: 4px; font-size: 0.85em;">
                            <span style="color: #aaa;">Filter: </span>
                            <span id="captureDateFilterValue" style="color: #e94560;"></span>
                            <button onclick="clearCaptureDateFilter()" style="background: none; border: none; color: #888; margin-left: 6px; cursor: pointer; font-size: 1.1em;" title="Clear filter">×</button>
                        </div>
                    </div>
                    <div style="height: 150px;">
                        <canvas id="imagesAnalyzedHistogram"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Browse Results</h2>
            <p style="color: #888; margin-bottom: 15px; font-size: 0.9em;">
                Click on the histograms above or use the filters below to filter results by date.
            </p>

            <!-- Filter Controls -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- Processed Date Filter -->
                <div style="background: #0f3460; border-radius: 8px; padding: 15px;">
                    <h4 style="color: #4CAF50; margin-bottom: 12px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">Filter by Result Generated Date</h4>
                    <div class="date-time-inputs" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label style="font-size: 0.85em;">From</label>
                            <input type="date" id="processedFromDate" onchange="updateProcessedDateFilter()">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label style="font-size: 0.85em;">To</label>
                            <input type="date" id="processedToDate" onchange="updateProcessedDateFilter()">
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="clearProcessedDateFilter()" style="padding: 6px 12px; font-size: 0.85em; width: 100%;">Clear Filter</button>
                </div>

                <!-- Capture Date Filter -->
                <div style="background: #0f3460; border-radius: 8px; padding: 15px;">
                    <h4 style="color: #e94560; margin-bottom: 12px; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px;">Filter by Image Capture Date</h4>
                    <div class="date-time-inputs" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label style="font-size: 0.85em;">From</label>
                            <input type="date" id="captureFromDate" onchange="updateCaptureDateFilter()">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label style="font-size: 0.85em;">To</label>
                            <input type="date" id="captureToDate" onchange="updateCaptureDateFilter()">
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="clearCaptureDateFilter()" style="padding: 6px 12px; font-size: 0.85em; width: 100%;">Clear Filter</button>
                </div>
            </div>

            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                <button class="btn btn-primary" onclick="applyFilters()" style="padding: 10px 20px;">Apply Filters</button>
                <button class="btn btn-secondary" onclick="clearAllFilters()" style="padding: 10px 20px;">Clear All Filters</button>
            </div>

            <div class="results-list" id="resultsList"></div>
        </div>
    </div>

    <!-- Modal for unwarped images -->
    <div class="modal-overlay" id="unwarpedModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-nav">
                    <button class="nav-arrow" id="prevImageBtn" onclick="navigateImage(-1)" title="Previous image (Left Arrow)">&#9664;</button>
                    <span class="image-counter" id="imageCounter"></span>
                    <button class="nav-arrow" id="nextImageBtn" onclick="navigateImage(1)" title="Next image (Right Arrow)">&#9654;</button>
                </div>
                <h3 id="modalTitle">Unwarped Views</h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-primary" id="unwarpButton" onclick="manualUnwarp()" style="display: none;">
                        Unwarp This Image
                    </button>
                    <button class="btn btn-success" id="modalProcessButton" onclick="goToProcessTab()" style="display: none;">
                        Process Images
                    </button>
                    <span id="unwarpStatus" style="color: #888; font-size: 0.9em;"></span>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="unwarped-grid" id="unwarpedGrid"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen image viewer -->
    <div class="fullscreen-overlay" id="fullscreenViewer" onclick="closeFullscreen()">
        <div class="fullscreen-container">
            <div class="fullscreen-nav">
                <button class="fullscreen-nav-btn" id="fullscreenPrevBtn" onclick="navigateFullscreen(-1); event.stopPropagation();" title="Previous image (Left Arrow)">&#9664;</button>
                <div class="fullscreen-info">
                    <span class="fullscreen-counter" id="fullscreenCounter"></span>
                    <span class="fullscreen-label" id="fullscreenLabel"></span>
                </div>
                <button class="fullscreen-nav-btn" id="fullscreenNextBtn" onclick="navigateFullscreen(1); event.stopPropagation();" title="Next image (Right Arrow)">&#9654;</button>
                <button class="selection-toggle-btn" id="fullscreenSelectBtn" onclick="toggleCurrentFullscreenSelection(); event.stopPropagation();">Select Image</button>
            </div>
            <img id="fullscreenImg" src="" alt="" onclick="event.stopPropagation()">
            <button class="fullscreen-close" onclick="closeFullscreen(); event.stopPropagation();" title="Close (Esc)">&#10005;</button>
        </div>
    </div>

    <script>
        let histogramChart = null;
        let statsData = null;
        let currentImages = [];
        let currentImageKey = null;
        let currentImageFilename = null;
        let currentImageIndex = -1;
        let fullscreenImages = [];
        let currentFullscreenIndex = -1;
        let fullscreenContext = 'explorer'; // 'explorer' or 'process'
        let selectedImages = []; // Array of {url, label, imageKey, filename, s3Key}

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');

                // Load data when switching to results tab
                if (tab.dataset.tab === 'results') {
                    loadResultStats();
                    loadAllResults();
                }

                // Update process tab when switching to it
                if (tab.dataset.tab === 'process') {
                    renderProcessTab();
                }
            });
        });

        // Date Range Selector Functions
        function toggleDateRangeSelector() {
            document.getElementById('dateRangeSelector').classList.toggle('open');
        }

        function openDateSelector() {
            document.getElementById('dateRangeSelector').classList.add('open');
        }

        function updateDateSummary() {
            const fromDate = document.getElementById('fromDate').value;
            const toDate = document.getElementById('toDate').value;
            const fromTime = document.getElementById('fromTime').value;
            const toTime = document.getElementById('toTime').value;

            document.getElementById('summaryFrom').textContent = fromDate;
            document.getElementById('summaryTo').textContent = toDate;
            document.getElementById('summaryTime').textContent = `${fromTime} - ${toTime}`;
        }

        function quickSelect(preset) {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];

            let fromDate = todayStr;
            let toDate = todayStr;
            let fromTime = '00:00';
            let toTime = '23:59';

            switch (preset) {
                case 'today':
                    fromDate = toDate = todayStr;
                    break;
                case 'yesterday':
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    fromDate = toDate = yesterday.toISOString().split('T')[0];
                    break;
                case 'week':
                    const weekAgo = new Date(today);
                    weekAgo.setDate(weekAgo.getDate() - 7);
                    fromDate = weekAgo.toISOString().split('T')[0];
                    toDate = todayStr;
                    break;
                case 'month':
                    const monthAgo = new Date(today);
                    monthAgo.setDate(monthAgo.getDate() - 30);
                    fromDate = monthAgo.toISOString().split('T')[0];
                    toDate = todayStr;
                    break;
                case 'morning':
                    fromTime = '06:00';
                    toTime = '12:00';
                    break;
                case 'afternoon':
                    fromTime = '12:00';
                    toTime = '18:00';
                    break;
                case 'evening':
                    fromTime = '18:00';
                    toTime = '23:59';
                    break;
            }

            document.getElementById('fromDate').value = fromDate;
            document.getElementById('toDate').value = toDate;
            document.getElementById('fromTime').value = fromTime;
            document.getElementById('toTime').value = toTime;
            updateDateSummary();

            // Update quick select button styles
            document.querySelectorAll('.quick-select-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function resetDateRange() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('fromDate').value = today;
            document.getElementById('toDate').value = today;
            document.getElementById('fromTime').value = '00:00';
            document.getElementById('toTime').value = '23:59';
            updateDateSummary();
            document.querySelectorAll('.quick-select-btn').forEach(btn => btn.classList.remove('active'));
        }

        function setDateFromHistogram(date) {
            document.getElementById('fromDate').value = date;
            document.getElementById('toDate').value = date;
            document.getElementById('fromTime').value = '00:00';
            document.getElementById('toTime').value = '23:59';
            updateDateSummary();

            // Clear quick select buttons
            document.querySelectorAll('.quick-select-btn').forEach(btn => btn.classList.remove('active'));

            // Automatically load images for the selected date
            loadImagesForRange();
        }

        // Load stats and histogram on page load
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                statsData = await response.json();

                // Check if there's an error in the response
                if (statsData.error) {
                    const errorBanner = document.getElementById('credentialError');
                    const errorMessage = document.getElementById('credentialErrorMessage');

                    if (statsData.error === 'credentials') {
                        errorMessage.innerHTML = `
                            ${statsData.error_message}
                            <pre>Please configure AWS credentials using one of these methods:
1. Environment variables:
   export AWS_ACCESS_KEY_ID="your-access-key"
   export AWS_SECRET_ACCESS_KEY="your-secret-key"
   export AWS_DEFAULT_REGION="eu-central-1"

2. AWS credentials file (~/.aws/credentials):
   [default]
   aws_access_key_id = your-access-key
   aws_secret_access_key = your-secret-key

3. IAM role (if running on EC2/ECS)</pre>
                        `;
                    } else {
                        errorMessage.textContent = statsData.error_message;
                    }

                    errorBanner.style.display = 'block';

                    // Set placeholder values
                    document.getElementById('totalImages').textContent = '-';
                    document.getElementById('totalDays').textContent = '-';
                    document.getElementById('dateRange').textContent = 'N/A';
                    return;
                }

                // Hide error banner if credentials are working
                document.getElementById('credentialError').style.display = 'none';

                document.getElementById('totalImages').textContent = statsData.total_images.toLocaleString();
                document.getElementById('totalDays').textContent = statsData.total_days;

                if (statsData.first_date && statsData.last_date) {
                    document.getElementById('dateRange').textContent =
                        `${statsData.first_date} to ${statsData.last_date}`;
                }

                renderHistogram(statsData);
            } catch (error) {
                console.error('Failed to load stats:', error);
                const errorBanner = document.getElementById('credentialError');
                const errorMessage = document.getElementById('credentialErrorMessage');
                errorMessage.textContent = `Failed to connect to server: ${error.message}`;
                errorBanner.style.display = 'block';
            }
        }

        function renderHistogram(data) {
            const ctx = document.getElementById('histogram').getContext('2d');

            if (histogramChart) {
                histogramChart.destroy();
            }

            histogramChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.dates,
                    datasets: [{
                        label: 'Images',
                        data: data.counts,
                        backgroundColor: 'rgba(233, 69, 96, 0.6)',
                        borderColor: 'rgba(233, 69, 96, 1)',
                        borderWidth: 1,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const selectedDate = data.dates[index];
                            setDateFromHistogram(selectedDate);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (item) => `${item.parsed.y} images - click to select`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            grid: { display: false },
                            ticks: { color: '#888' }
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: '#888', precision: 0 }
                        }
                    }
                }
            });
        }

        async function loadImagesForRange() {
            const fromDate = document.getElementById('fromDate').value;
            const toDate = document.getElementById('toDate').value;
            const fromTime = document.getElementById('fromTime').value;
            const toTime = document.getElementById('toTime').value;

            if (!fromDate || !toDate) return;

            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '<div class="empty-state"><div class="spinner"></div> Loading...</div>';

            // Collapse the selector
            document.getElementById('dateRangeSelector').classList.remove('open');

            try {
                const params = new URLSearchParams({
                    from_date: fromDate,
                    to_date: toDate,
                    from_time: fromTime,
                    to_time: toTime
                });
                const response = await fetch(`/api/images?${params}`);
                const data = await response.json();

                currentImages = data.images;

                document.getElementById('dayStats').style.display = 'flex';
                document.getElementById('dayImageCount').textContent = data.count;

                if (data.count === 0) {
                    grid.innerHTML = '<div class="empty-state">No images found in this range</div>';
                    return;
                }

                grid.innerHTML = data.images.map((img, index) => {
                    const selectionCount = getSelectionCountForImage(img.key);
                    const hasSelection = selectionCount > 0;
                    const badge = hasSelection ? `<div class="selection-badge"><span>&#10003;</span> ${selectionCount}</div>` : '';

                    return `
                        <div class="image-card ${hasSelection ? 'has-selection' : ''}" data-image-key="${img.key}" onclick="showUnwarped('${img.key}', '${img.filename}', ${index})">
                            ${badge}
                            <img src="${img.url}" alt="${img.filename}" loading="lazy">
                            <div class="info">
                                <div class="filename">${img.filename}</div>
                                <div class="time">${img.date} ${img.time}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                grid.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
            }
        }

        async function showUnwarped(imageKey, filename, index = -1) {
            const modal = document.getElementById('unwarpedModal');
            const grid = document.getElementById('unwarpedGrid');
            const title = document.getElementById('modalTitle');
            const unwarpButton = document.getElementById('unwarpButton');
            const unwarpStatus = document.getElementById('unwarpStatus');

            // Store current image info globally
            currentImageKey = imageKey;
            currentImageFilename = filename;
            currentImageIndex = index;

            // Reset fullscreen images for new modal
            fullscreenImages = [];
            currentFullscreenIndex = -1;

            // Update navigation buttons
            updateNavigationButtons();

            title.textContent = filename;
            grid.innerHTML = '<div class="empty-state"><div class="spinner"></div> Loading unwarped images...</div>';
            unwarpButton.style.display = 'none';
            unwarpStatus.textContent = '';
            modal.classList.add('show');

            try {
                const response = await fetch(`/api/unwarped?image_key=${encodeURIComponent(imageKey)}`);
                const data = await response.json();

                const directions = ['north', 'east', 'south', 'west', 'below'];

                // Check if any unwarped images exist
                const anyExist = directions.some(dir => data.unwarped[dir]?.exists);

                // Show unwarp button if no images exist
                if (!anyExist) {
                    unwarpButton.style.display = 'block';
                }

                // Get the fisheye image URL from currentImages
                let fisheyeUrl = '';
                if (currentImageIndex >= 0 && currentImageIndex < currentImages.length) {
                    fisheyeUrl = currentImages[currentImageIndex].url;
                }

                // Build grid with fisheye first, then unwarped images
                let gridHTML = '';

                // Add fisheye image
                if (fisheyeUrl) {
                    gridHTML += `
                        <div class="unwarped-item fisheye" data-label="Original Fisheye">
                            <div class="direction">Original Fisheye</div>
                            <img src="${fisheyeUrl}" alt="Original Fisheye" onclick="openFullscreen('${fisheyeUrl}', 'Original Fisheye')" style="cursor: zoom-in;">
                        </div>
                    `;
                }

                // Add unwarped images
                gridHTML += directions.map(dir => {
                    const item = data.unwarped[dir];
                    if (item && item.exists) {
                        const s3Key = item.s3_key || '';
                        return `
                            <div class="unwarped-item" data-url="${item.url}" data-label="${item.direction}">
                                <div class="direction">
                                    <span>${item.direction}</span>
                                    <input type="checkbox" class="selection-checkbox"
                                           onclick="event.stopPropagation(); toggleImageSelection('${item.url}', '${item.direction}', '${s3Key}')">
                                </div>
                                <img src="${item.url}" alt="${item.direction}" onclick="openFullscreen('${item.url}', '${item.direction}')" style="cursor: zoom-in;">
                            </div>
                        `;
                    } else {
                        return `
                            <div class="unwarped-item not-available">
                                <div class="direction">${dir}</div>
                                <div class="not-found">Not available</div>
                            </div>
                        `;
                    }
                }).join('');

                grid.innerHTML = gridHTML;

                // Update selection UI to reflect current selections
                updateSelectionUI();

                // Check if auto-unwarp is enabled
                const autoUnwarp = document.getElementById('autoUnwarpCheckbox').checked;
                if (autoUnwarp && !anyExist) {
                    // Automatically trigger unwarp
                    await triggerUnwarp();
                }
            } catch (error) {
                grid.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            const counter = document.getElementById('imageCounter');

            if (currentImageIndex < 0 || currentImages.length === 0) {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                counter.textContent = '';
            } else {
                prevBtn.disabled = currentImageIndex <= 0;
                nextBtn.disabled = currentImageIndex >= currentImages.length - 1;
                counter.textContent = `${currentImageIndex + 1} / ${currentImages.length}`;
            }
        }

        function navigateImage(direction) {
            if (currentImages.length === 0 || currentImageIndex < 0) return;

            const newIndex = currentImageIndex + direction;
            if (newIndex < 0 || newIndex >= currentImages.length) return;

            const img = currentImages[newIndex];
            showUnwarped(img.key, img.filename, newIndex);
        }

        async function triggerUnwarp() {
            const unwarpButton = document.getElementById('unwarpButton');
            const unwarpStatus = document.getElementById('unwarpStatus');
            const grid = document.getElementById('unwarpedGrid');

            if (!currentImageKey) return;

            unwarpButton.disabled = true;
            unwarpStatus.innerHTML = '<div class="spinner"></div> Unwarping...';
            grid.innerHTML = '<div class="empty-state"><div class="spinner"></div> Unwarping...</div>';

            try {
                const response = await fetch(`/api/unwarp?image_key=${encodeURIComponent(currentImageKey)}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Unwarp failed');
                }

                const data = await response.json();

                unwarpStatus.textContent = 'Unwarp complete! Refreshing...';
                unwarpButton.style.display = 'none';

                // Refresh the unwarped images after a short delay
                setTimeout(() => {
                    showUnwarped(currentImageKey, currentImageFilename, currentImageIndex);
                }, 2000);

            } catch (error) {
                unwarpStatus.textContent = `Error: ${error.message}`;
                unwarpButton.disabled = false;
                grid.innerHTML = `<div class="empty-state" style="color: #f44336;">Error: ${error.message}</div>`;
            }
        }

        async function manualUnwarp() {
            await triggerUnwarp();
        }

        function closeModal() {
            document.getElementById('unwarpedModal').classList.remove('show');
            // Don't reset currentImageIndex so we can reopen at the same position if needed
        }

        function buildFullscreenImages() {
            // Build array of all available images in the current modal view
            fullscreenImages = [];

            // Get all unwarped-item elements from the modal
            const items = document.querySelectorAll('#unwarpedGrid .unwarped-item:not(.not-available)');
            items.forEach(item => {
                const img = item.querySelector('img');
                const label = item.dataset.label;
                if (img && label) {
                    fullscreenImages.push({
                        url: img.src,
                        label: label
                    });
                }
            });
        }

        function openFullscreen(url, label = '') {
            event.stopPropagation();

            // Set context to explorer (opened from modal)
            fullscreenContext = 'explorer';

            // Build the images array if not already built
            if (fullscreenImages.length === 0) {
                buildFullscreenImages();
            }

            // Find the index of the current image
            currentFullscreenIndex = fullscreenImages.findIndex(img => img.url === url);

            // If not found and label is provided, try to find by label
            if (currentFullscreenIndex === -1 && label) {
                currentFullscreenIndex = fullscreenImages.findIndex(img =>
                    img.label.toLowerCase() === label.toLowerCase()
                );
            }

            // If still not found, add it
            if (currentFullscreenIndex === -1) {
                fullscreenImages.push({ url, label: label || 'Image' });
                currentFullscreenIndex = fullscreenImages.length - 1;
            }

            updateFullscreenDisplay();
            document.getElementById('fullscreenViewer').classList.add('show');
        }

        function updateFullscreenDisplay() {
            if (currentFullscreenIndex < 0 || currentFullscreenIndex >= fullscreenImages.length) {
                return;
            }

            const currentImage = fullscreenImages[currentFullscreenIndex];
            document.getElementById('fullscreenImg').src = currentImage.url;
            document.getElementById('fullscreenLabel').textContent = currentImage.label;
            document.getElementById('fullscreenCounter').textContent =
                `${currentFullscreenIndex + 1} / ${fullscreenImages.length}`;

            // Update navigation buttons
            const prevBtn = document.getElementById('fullscreenPrevBtn');
            const nextBtn = document.getElementById('fullscreenNextBtn');
            prevBtn.disabled = currentFullscreenIndex <= 0;
            nextBtn.disabled = currentFullscreenIndex >= fullscreenImages.length - 1;

            // Update selection button (hide for fisheye)
            const selectBtn = document.getElementById('fullscreenSelectBtn');
            if (currentImage.label === 'Original Fisheye') {
                selectBtn.style.display = 'none';
            } else {
                selectBtn.style.display = 'flex';
                updateFullscreenSelectionButton(currentImage.label);
            }
        }

        function navigateFullscreen(direction) {
            if (fullscreenImages.length === 0) return;

            const newIndex = currentFullscreenIndex + direction;
            if (newIndex < 0 || newIndex >= fullscreenImages.length) return;

            currentFullscreenIndex = newIndex;
            updateFullscreenDisplay();
        }

        function closeFullscreen() {
            document.getElementById('fullscreenViewer').classList.remove('show');
            // Reset fullscreen images when closing
            fullscreenImages = [];
            currentFullscreenIndex = -1;
            fullscreenContext = 'explorer';
        }

        // Selection functions
        function getImageIdentifier(imageKey, label) {
            return `${imageKey}|${label}`;
        }

        function isImageSelected(imageKey, label) {
            const identifier = getImageIdentifier(imageKey, label);
            return selectedImages.some(img => getImageIdentifier(img.imageKey, img.label) === identifier);
        }

        function toggleImageSelection(url, label, s3Key = '') {
            const identifier = getImageIdentifier(currentImageKey, label);
            const index = selectedImages.findIndex(img => getImageIdentifier(img.imageKey, img.label) === identifier);

            if (index >= 0) {
                // Remove from selection
                selectedImages.splice(index, 1);
            } else {
                // Add to selection
                selectedImages.push({
                    url: url,
                    label: label,
                    imageKey: currentImageKey,
                    filename: currentImageFilename,
                    s3Key: s3Key
                });
            }

            updateSelectionUI();
            updateSelectedCount();
            updateImageGridSelectionBadges();
        }

        function updateSelectionUI() {
            // Update checkboxes in modal
            document.querySelectorAll('.unwarped-item:not(.fisheye):not(.not-available)').forEach(item => {
                const label = item.dataset.label;
                const checkbox = item.querySelector('.selection-checkbox');
                if (label && checkbox) {
                    const selected = isImageSelected(currentImageKey, label);
                    checkbox.checked = selected;
                    if (selected) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                }
            });

            // Update fullscreen toggle button if visible
            const fullscreenViewer = document.getElementById('fullscreenViewer');
            if (fullscreenViewer.classList.contains('show') && fullscreenImages.length > 0) {
                const currentImage = fullscreenImages[currentFullscreenIndex];
                updateFullscreenSelectionButton(currentImage.label);
            }
        }

        function updateFullscreenSelectionButton(label) {
            const btn = document.getElementById('fullscreenSelectBtn');
            if (!btn) return;

            let selected = false;

            if (fullscreenContext === 'process') {
                // In process tab, check the deselected state
                const currentImage = fullscreenImages[currentFullscreenIndex];
                selected = !currentImage.deselected;

                // Update button text for process context
                if (selected) {
                    btn.classList.add('selected');
                    btn.innerHTML = '<span class="checkmark">&#10003;</span> Enabled';
                } else {
                    btn.classList.remove('selected');
                    btn.innerHTML = 'Enable Image';
                }
            } else {
                // In explorer tab, check if image is in selectedImages
                selected = isImageSelected(currentImageKey, label);

                if (selected) {
                    btn.classList.add('selected');
                    btn.innerHTML = '<span class="checkmark">&#10003;</span> Selected';
                } else {
                    btn.classList.remove('selected');
                    btn.innerHTML = 'Select Image';
                }
            }
        }

        function toggleCurrentFullscreenSelection() {
            if (fullscreenImages.length === 0 || currentFullscreenIndex < 0) return;

            const currentImage = fullscreenImages[currentFullscreenIndex];
            // Don't allow selecting the fisheye image
            if (currentImage.label === 'Original Fisheye') return;

            if (fullscreenContext === 'process') {
                // In process tab, toggle the deselected state
                if (typeof currentImage.originalIndex !== 'undefined' && currentImage.originalIndex >= 0) {
                    toggleImageInProcess(currentImage.originalIndex);
                    // Sync the fullscreen image state with the actual selectedImages state
                    fullscreenImages[currentFullscreenIndex].deselected = selectedImages[currentImage.originalIndex].deselected;
                    updateFullscreenDisplay();
                }
            } else {
                // In explorer tab, use normal selection toggle
                toggleImageSelection(currentImage.url, currentImage.label);
            }
        }

        function updateSelectedCount() {
            const countEl = document.getElementById('selectedImageCount');
            const countValue = document.getElementById('selectedImageCountValue');
            const processBtn = document.getElementById('processImageBtn');
            const modalProcessBtn = document.getElementById('modalProcessButton');

            if (countValue) {
                countValue.textContent = selectedImages.length;
            }

            if (processBtn) {
                if (selectedImages.length > 0) {
                    processBtn.disabled = false;
                    processBtn.title = '';
                } else {
                    processBtn.disabled = true;
                    processBtn.title = 'Select an image to process first';
                }
            }

            if (modalProcessBtn) {
                if (selectedImages.length > 0) {
                    modalProcessBtn.style.display = 'block';
                } else {
                    modalProcessBtn.style.display = 'none';
                }
            }
        }

        function goToProcessTab() {
            // Switch to the process tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            const processTab = document.querySelector('.tab[data-tab="process"]');
            processTab.classList.add('active');
            document.getElementById('process').classList.add('active');

            // Close modal if open
            closeModal();

            // Render the process tab
            renderProcessTab();
        }

        function getSelectionCountForImage(imageKey) {
            return selectedImages.filter(img => img.imageKey === imageKey).length;
        }

        function updateImageGridSelectionBadges() {
            // Update all image cards to show/hide selection badges
            document.querySelectorAll('.image-card').forEach(card => {
                const imageKey = card.dataset.imageKey;
                if (imageKey) {
                    const count = getSelectionCountForImage(imageKey);
                    let badge = card.querySelector('.selection-badge');

                    if (count > 0) {
                        card.classList.add('has-selection');
                        if (!badge) {
                            badge = document.createElement('div');
                            badge.className = 'selection-badge';
                            card.appendChild(badge);
                        }
                        badge.innerHTML = `<span>&#10003;</span> ${count}`;
                    } else {
                        card.classList.remove('has-selection');
                        if (badge) {
                            badge.remove();
                        }
                    }
                }
            });
        }

        // Process tab functions
        function renderProcessTab() {
            const grid = document.getElementById('selectedImagesGrid');
            const countEl = document.getElementById('processSelectedCount');
            const processBtn = document.getElementById('processBtn');
            const helpText = document.getElementById('processTabHelp');

            // Count only enabled (not deselected) images
            const enabledImages = selectedImages.filter(img => !img.deselected);
            countEl.textContent = enabledImages.length;

            if (selectedImages.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <p style="color: #666;">No images selected yet.</p>
                        <p style="color: #888; font-size: 0.9em; margin-top: 10px;">Go to the Image Explorer tab and select unwarped images to process.</p>
                    </div>
                `;
                processBtn.disabled = true;
                helpText.style.display = 'block';
                return;
            }

            // Hide help text when images are selected
            helpText.style.display = 'none';
            processBtn.disabled = enabledImages.length === 0;

            // Group images by imageKey (same fisheye source)
            const groupedImages = {};
            selectedImages.forEach((img, index) => {
                if (!groupedImages[img.imageKey]) {
                    groupedImages[img.imageKey] = [];
                }
                groupedImages[img.imageKey].push({ ...img, originalIndex: index });
            });

            // Render groups as rows
            let html = '';
            for (const [imageKey, images] of Object.entries(groupedImages)) {
                // Create a row for each fisheye source
                html += '<div style="margin-bottom: 20px; padding: 15px; background: #0a2a4a; border-radius: 8px;">';

                // Add a label for the group
                html += `<div style="color: #e94560; font-weight: 600; margin-bottom: 10px;">From: ${images[0].filename}</div>`;

                // Create a grid that adapts to the number of images
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">`;

                images.forEach(img => {
                    const isDeselected = img.deselected;
                    const opacity = isDeselected ? '0.4' : '1';
                    const borderColor = isDeselected ? '#666' : '#4CAF50';

                    html += `
                        <div class="unwarped-item ${isDeselected ? '' : 'selected'}" style="opacity: ${opacity}; border-color: ${borderColor};">
                            <div class="direction" style="${isDeselected ? 'background: #666;' : ''}">
                                <span>${img.label}</span>
                                <button onclick="toggleImageInProcess(${img.originalIndex}); event.stopPropagation();"
                                        style="background: none; border: none; color: white; cursor: pointer; font-size: 18px;"
                                        title="${isDeselected ? 'Reselect image' : 'Deselect image'}">
                                    ${isDeselected ? '&#10003;' : '&#10005;'}
                                </button>
                            </div>
                            <img src="${img.url}" alt="${img.label}" onclick="openProcessFullscreen(${img.originalIndex})" style="cursor: zoom-in; width: 100%; height: auto; display: block;">
                            <div style="padding: 10px; background: #1a4a8a; font-size: 0.85em; color: #ddd;">
                                ${img.s3Key ? `<div style="word-break: break-all; color: #888;"><strong>S3:</strong> ${img.s3Key}</div>` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div>'; // Close grid
                html += '</div>'; // Close group container
            }

            grid.innerHTML = html;
        }

        function toggleImageInProcess(index) {
            if (index >= 0 && index < selectedImages.length) {
                // Toggle the deselected state
                selectedImages[index].deselected = !selectedImages[index].deselected;
                renderProcessTab();
            }
        }

        function openProcessFullscreen(index) {
            if (index < 0 || index >= selectedImages.length) return;

            // Set context to process tab
            fullscreenContext = 'process';

            // Build fullscreen images from selected images, including the originalIndex
            fullscreenImages = selectedImages.map((img, idx) => ({
                url: img.url,
                label: img.label,
                originalIndex: idx,
                deselected: img.deselected || false
            }));
            currentFullscreenIndex = index;

            updateFullscreenDisplay();
            document.getElementById('fullscreenViewer').classList.add('show');
        }

        async function processSelectedImages() {
            const prompt = document.getElementById('processPrompt').value;
            const model = document.getElementById('processModel').value;
            const status = document.getElementById('processStatus');
            const btn = document.getElementById('processBtn');

            // Only process images that are not deselected
            const imagesToProcess = selectedImages.filter(img => !img.deselected);

            if (imagesToProcess.length === 0) return;

            status.className = 'processing-status loading';
            status.innerHTML = '<div class="spinner"></div> Processing selected images... This may take a while.';
            btn.disabled = true;

            try {
                // Process each selected image
                let results = [];
                let errors = [];

                for (let i = 0; i < imagesToProcess.length; i++) {
                    const img = imagesToProcess[i];
                    status.innerHTML = `<div class="spinner"></div> Processing ${i + 1}/${imagesToProcess.length}: ${img.label} (${img.filename})...`;

                    try {
                        // If we have an s3Key, use it; otherwise construct from imageKey
                        const s3Uri = img.s3Key ? `s3://vibecast-ftp/${img.s3Key}` : `s3://vibecast-ftp/${img.imageKey}`;

                        // Map direction label to short code
                        const directionMap = {
                            'north': 'N', 'south': 'S', 'east': 'E', 'west': 'W', 'below': 'B', 'bottom': 'B'
                        };
                        const viewCode = directionMap[img.label.toLowerCase()];

                        const response = await fetch('/api/process', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                s3_uri: s3Uri,
                                prompt: prompt || null,
                                model: model || null,
                                views_to_analyze: viewCode ? [viewCode] : null
                            })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            results.push({ image: img, result: data });
                        } else {
                            errors.push({ image: img, error: data.detail || 'Processing failed' });
                        }
                    } catch (error) {
                        errors.push({ image: img, error: error.message });
                    }
                }

                // Show results
                if (errors.length === 0) {
                    status.className = 'processing-status success';
                    status.innerHTML = `
                        <strong>All ${results.length} images processed successfully!</strong><br>
                        <div style="margin-top: 10px; max-height: 300px; overflow-y: auto;">
                            ${results.map(r => `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 4px;">
                                    <strong>${r.image.label}</strong> - ${r.image.filename}<br>
                                    <pre style="margin-top: 5px; white-space: pre-wrap; font-size: 11px;">${JSON.stringify(r.result, null, 2)}</pre>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (results.length === 0) {
                    status.className = 'processing-status error';
                    status.innerHTML = `
                        <strong>All images failed to process</strong><br>
                        <div style="margin-top: 10px; max-height: 300px; overflow-y: auto;">
                            ${errors.map(e => `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(244, 67, 54, 0.1); border-radius: 4px;">
                                    <strong>${e.image.label}</strong> - ${e.image.filename}<br>
                                    Error: ${e.error}
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    status.className = 'processing-status success';
                    status.innerHTML = `
                        <strong>Processed ${results.length} successfully, ${errors.length} failed</strong><br>
                        <div style="margin-top: 10px; max-height: 300px; overflow-y: auto;">
                            ${results.map(r => `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 4px;">
                                    <strong>✓ ${r.image.label}</strong> - ${r.image.filename}
                                </div>
                            `).join('')}
                            ${errors.map(e => `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(244, 67, 54, 0.1); border-radius: 4px;">
                                    <strong>✗ ${e.image.label}</strong> - ${e.image.filename}<br>
                                    Error: ${e.error}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            } catch (error) {
                status.className = 'processing-status error';
                status.textContent = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }

        // Results tab functions
        let resultsGeneratedChart = null;
        let imagesAnalyzedChart = null;
        let resultsStatsData = null;
        let processedDateFilter = { from: null, to: null }; // Filter for when result was generated
        let captureDateFilter = { from: null, to: null };   // Filter for when image was captured

        async function loadResultStats() {
            try {
                const response = await fetch('/api/result-stats');
                resultsStatsData = await response.json();

                if (resultsStatsData.error) {
                    document.getElementById('totalResults').textContent = '-';
                    document.getElementById('totalImagesAnalyzed').textContent = '-';
                    return;
                }

                document.getElementById('totalResults').textContent = resultsStatsData.total_results.toLocaleString();
                document.getElementById('totalImagesAnalyzed').textContent = resultsStatsData.total_images_analyzed.toLocaleString();

                renderResultsHistograms(resultsStatsData);
            } catch (error) {
                console.error('Failed to load result stats:', error);
                document.getElementById('totalResults').textContent = '-';
                document.getElementById('totalImagesAnalyzed').textContent = '-';
            }
        }

        function renderResultsHistograms(data) {
            // Results Generated Histogram
            const ctx1 = document.getElementById('resultsGeneratedHistogram').getContext('2d');
            if (resultsGeneratedChart) {
                resultsGeneratedChart.destroy();
            }
            resultsGeneratedChart = new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: data.results_generated.dates,
                    datasets: [{
                        label: 'Results',
                        data: data.results_generated.counts,
                        backgroundColor: 'rgba(76, 175, 80, 0.6)',
                        borderColor: 'rgba(76, 175, 80, 1)',
                        borderWidth: 1,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const selectedDate = data.results_generated.dates[index];
                            setProcessedDateFilter(selectedDate);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (item) => `${item.parsed.y} results - click to select`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            grid: { display: false },
                            ticks: { color: '#888' }
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: '#888', precision: 0 }
                        }
                    }
                }
            });

            // Images Analyzed Histogram
            const ctx2 = document.getElementById('imagesAnalyzedHistogram').getContext('2d');
            if (imagesAnalyzedChart) {
                imagesAnalyzedChart.destroy();
            }
            imagesAnalyzedChart = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: data.images_analyzed.dates,
                    datasets: [{
                        label: 'Images',
                        data: data.images_analyzed.counts,
                        backgroundColor: 'rgba(233, 69, 96, 0.6)',
                        borderColor: 'rgba(233, 69, 96, 1)',
                        borderWidth: 1,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const selectedDate = data.images_analyzed.dates[index];
                            setCaptureDateFilter(selectedDate);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (item) => `${item.parsed.y} images - click to select`
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: { day: 'MMM d' }
                            },
                            grid: { display: false },
                            ticks: { color: '#888' }
                        },
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255,255,255,0.05)' },
                            ticks: { color: '#888', precision: 0 }
                        }
                    }
                }
            });
        }

        function setProcessedDateFilter(date) {
            // Set both from and to to the same date (single date selection from histogram)
            processedDateFilter = { from: date, to: date };
            document.getElementById('processedFromDate').value = date;
            document.getElementById('processedToDate').value = date;
            updateProcessedDateFilterDisplay();
            loadResultsWithFilters();
        }

        function setCaptureDateFilter(date) {
            // Set both from and to to the same date (single date selection from histogram)
            captureDateFilter = { from: date, to: date };
            document.getElementById('captureFromDate').value = date;
            document.getElementById('captureToDate').value = date;
            updateCaptureDateFilterDisplay();
            loadResultsWithFilters();
        }

        function updateProcessedDateFilter() {
            const from = document.getElementById('processedFromDate').value;
            const to = document.getElementById('processedToDate').value;
            processedDateFilter = { from, to };
            updateProcessedDateFilterDisplay();
        }

        function updateCaptureDateFilter() {
            const from = document.getElementById('captureFromDate').value;
            const to = document.getElementById('captureToDate').value;
            captureDateFilter = { from, to };
            updateCaptureDateFilterDisplay();
        }

        function updateProcessedDateFilterDisplay() {
            const { from, to } = processedDateFilter;
            if (from || to) {
                document.getElementById('processedDateFilter').style.display = 'flex';
                if (from && to && from === to) {
                    document.getElementById('processedDateFilterValue').textContent = from;
                } else if (from && to) {
                    document.getElementById('processedDateFilterValue').textContent = `${from} to ${to}`;
                } else if (from) {
                    document.getElementById('processedDateFilterValue').textContent = `from ${from}`;
                } else if (to) {
                    document.getElementById('processedDateFilterValue').textContent = `to ${to}`;
                }
            } else {
                document.getElementById('processedDateFilter').style.display = 'none';
            }
        }

        function updateCaptureDateFilterDisplay() {
            const { from, to } = captureDateFilter;
            if (from || to) {
                document.getElementById('captureDateFilter').style.display = 'flex';
                if (from && to && from === to) {
                    document.getElementById('captureDateFilterValue').textContent = from;
                } else if (from && to) {
                    document.getElementById('captureDateFilterValue').textContent = `${from} to ${to}`;
                } else if (from) {
                    document.getElementById('captureDateFilterValue').textContent = `from ${from}`;
                } else if (to) {
                    document.getElementById('captureDateFilterValue').textContent = `to ${to}`;
                }
            } else {
                document.getElementById('captureDateFilter').style.display = 'none';
            }
        }

        function clearProcessedDateFilter() {
            processedDateFilter = { from: null, to: null };
            document.getElementById('processedFromDate').value = '';
            document.getElementById('processedToDate').value = '';
            document.getElementById('processedDateFilter').style.display = 'none';
            loadResultsWithFilters();
        }

        function clearCaptureDateFilter() {
            captureDateFilter = { from: null, to: null };
            document.getElementById('captureFromDate').value = '';
            document.getElementById('captureToDate').value = '';
            document.getElementById('captureDateFilter').style.display = 'none';
            loadResultsWithFilters();
        }

        function clearAllFilters() {
            processedDateFilter = { from: null, to: null };
            captureDateFilter = { from: null, to: null };
            document.getElementById('processedFromDate').value = '';
            document.getElementById('processedToDate').value = '';
            document.getElementById('captureFromDate').value = '';
            document.getElementById('captureToDate').value = '';
            document.getElementById('processedDateFilter').style.display = 'none';
            document.getElementById('captureDateFilter').style.display = 'none';
            loadResultsWithFilters();
        }

        function applyFilters() {
            updateProcessedDateFilter();
            updateCaptureDateFilter();
            loadResultsWithFilters();
        }

        async function loadResultsWithFilters() {
            await fetchResults('/api/results');
        }

        async function loadAllResults() {
            clearAllFilters();
        }

        async function fetchResults(url) {
            const list = document.getElementById('resultsList');
            list.innerHTML = '<div class="empty-state"><div class="spinner"></div> Loading results...</div>';

            try {
                const response = await fetch(url);
                const data = await response.json();

                let results = data.results;

                // Apply filters if set
                const hasProcessedFilter = processedDateFilter.from || processedDateFilter.to;
                const hasCaptureFilter = captureDateFilter.from || captureDateFilter.to;

                if (hasProcessedFilter || hasCaptureFilter) {
                    // We need to fetch each result JSON to check filters
                    const filteredResults = [];

                    for (const result of results) {
                        try {
                            // Fetch result JSON
                            const resultResponse = await fetch(`/api/result?key=${encodeURIComponent(result.key)}`);
                            const resultData = await resultResponse.json();

                            let passesFilters = true;

                            // Check processed date filter (range)
                            if (hasProcessedFilter) {
                                if (resultData.processed_at) {
                                    const processedDate = resultData.processed_at.split('T')[0];
                                    if (processedDateFilter.from && processedDate < processedDateFilter.from) {
                                        passesFilters = false;
                                    }
                                    if (processedDateFilter.to && processedDate > processedDateFilter.to) {
                                        passesFilters = false;
                                    }
                                } else {
                                    passesFilters = false;
                                }
                            }

                            // Check capture date filter (range)
                            if (passesFilters && hasCaptureFilter) {
                                if (resultData.input_uri) {
                                    const inputFilename = resultData.input_uri.split('/').pop();
                                    // Parse filename to get date (reolink_00_YYYYMMDDHHMMSS.jpg)
                                    const match = inputFilename.match(/\d{14}/);
                                    if (match) {
                                        const timestamp = match[0];
                                        const captureDate = `${timestamp.substr(0,4)}-${timestamp.substr(4,2)}-${timestamp.substr(6,2)}`;
                                        if (captureDateFilter.from && captureDate < captureDateFilter.from) {
                                            passesFilters = false;
                                        }
                                        if (captureDateFilter.to && captureDate > captureDateFilter.to) {
                                            passesFilters = false;
                                        }
                                    } else {
                                        passesFilters = false;
                                    }
                                } else {
                                    passesFilters = false;
                                }
                            }

                            if (passesFilters) {
                                filteredResults.push(result);
                            }
                        } catch (e) {
                            console.error(`Error filtering result ${result.key}:`, e);
                        }
                    }

                    results = filteredResults;
                }

                if (results.length === 0) {
                    list.innerHTML = '<div class="empty-state">No results found</div>';
                    return;
                }

                list.innerHTML = results.map((result, i) => `
                    <div class="result-card">
                        <div class="result-header" onclick="toggleResult(${i}, '${result.key}')">
                            <span>${result.filename}</span>
                            <span style="color: #888; font-size: 0.9em;">${result.date || ''} - ${result.last_modified ? new Date(result.last_modified).toLocaleString() : ''}</span>
                        </div>
                        <div class="result-body" id="resultBody${i}"></div>
                    </div>
                `).join('');
            } catch (error) {
                list.innerHTML = `<div class="empty-state">Error: ${error.message}</div>`;
            }
        }

        async function toggleResult(index, key) {
            const body = document.getElementById(`resultBody${index}`);

            if (body.classList.contains('show')) {
                body.classList.remove('show');
                return;
            }

            body.innerHTML = '<div class="spinner"></div> Loading...';
            body.classList.add('show');

            try {
                const response = await fetch(`/api/result?key=${encodeURIComponent(key)}`);
                const data = await response.json();

                // Store data for download
                window[`resultJsonData${index}`] = data;

                let html = '';

                // Download button
                html += `
                    <div style="margin-bottom: 15px;">
                        <button onclick="downloadResultJson(${index}, '${key.split('/').pop()}')" class="btn btn-secondary" style="padding: 8px 16px; font-size: 0.9em;">
                            ⬇ Download JSON
                        </button>
                    </div>
                `;

                // Show input image info and processed_at
                if (data.input_uri || data.processed_at) {
                    html += '<div style="margin-bottom: 15px; padding: 12px; background: #0a2a4a; border-radius: 8px; color: #888;">';
                    if (data.input_uri) {
                        html += `<div style="margin-bottom: 8px;"><strong style="color: #aaa;">Input:</strong> ${data.input_uri}</div>`;
                    }
                    if (data.processed_at) {
                        const processedDate = new Date(data.processed_at);
                        html += `<div><strong style="color: #aaa;">Processed:</strong> ${processedDate.toLocaleString()}</div>`;
                    }
                    html += '</div>';
                }

                // Show config and prompt side by side
                if (data.config) {
                    html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">';

                    // Config box (without prompt field)
                    const configCopy = {...data.config};
                    const prompt = configCopy.prompt || 'No prompt specified';
                    delete configCopy.prompt;

                    const isLongPrompt = prompt.length > 200;
                    html += `
                        <div style="padding: 15px; background: #16213e; border-radius: 8px; overflow: hidden;">
                            <strong style="color: #e94560;">Config:</strong>
                            <pre style="margin-top: 10px; color: #aaa; font-size: 12px; overflow-x: auto; max-width: 100%;">${JSON.stringify(configCopy, null, 2)}</pre>
                        </div>
                    `;

                    // Prompt box (scrollable/expandable)
                    html += `
                        <div style="padding: 15px; background: #16213e; border-radius: 8px; overflow: hidden;">
                            <strong style="color: #e94560;">Prompt:</strong>
                            <div id="promptBox${index}" style="margin-top: 10px; max-height: ${isLongPrompt ? '150px' : 'none'}; overflow-y: ${isLongPrompt ? 'auto' : 'visible'}; overflow-x: auto; color: #aaa; font-size: 12px; white-space: pre-wrap; border: ${isLongPrompt ? '1px solid #1a4a8a' : 'none'}; padding: ${isLongPrompt ? '8px' : '0'}; border-radius: 4px; max-width: 100%;">${prompt}</div>
                            ${isLongPrompt ? `<button onclick="togglePromptExpand(${index})" style="margin-top: 10px; padding: 5px 10px; background: #1a4a8a; color: #ddd; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Expand/Collapse</button>` : ''}
                        </div>
                    `;

                    html += '</div>';
                }

                // Show analysis_results if present
                if (data.analysis_results && Object.keys(data.analysis_results).length > 0) {
                    const analysisJson = JSON.stringify(data.analysis_results, null, 2);
                    const isLongAnalysis = analysisJson.length > 500;
                    html += `
                        <div style="margin-bottom: 20px; padding: 15px; background: #16213e; border-radius: 8px; overflow: hidden;">
                            <strong style="color: #e94560;">Analysis Results:</strong>
                            <pre id="analysisBox${index}" style="margin-top: 10px; max-height: ${isLongAnalysis ? '200px' : 'none'}; overflow-y: ${isLongAnalysis ? 'auto' : 'visible'}; overflow-x: auto; color: #aaa; font-size: 12px; white-space: pre-wrap; border: ${isLongAnalysis ? '1px solid #1a4a8a' : 'none'}; padding: ${isLongAnalysis ? '8px' : '0'}; border-radius: 4px; max-width: 100%;">${analysisJson}</pre>
                            ${isLongAnalysis ? `<button onclick="toggleAnalysisExpand(${index})" style="margin-top: 10px; padding: 5px 10px; background: #1a4a8a; color: #ddd; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Expand/Collapse</button>` : ''}
                        </div>
                    `;
                }

                // Button to toggle showing all images
                const showAllBtnId = `showAllBtn${index}`;
                html += `
                    <div style="margin-bottom: 15px;">
                        <button id="${showAllBtnId}" onclick="toggleShowAllImages(${index})" class="btn btn-secondary" style="padding: 8px 16px; font-size: 0.9em;">
                            Show All Images
                        </button>
                        <span id="imageCount${index}" style="color: #888; margin-left: 10px; font-size: 0.9em;"></span>
                    </div>
                `;

                // Show unwarped images with analysis
                if (data.unwarped_images && data.analysis_results) {
                    const analyzedViews = Object.keys(data.analysis_results);
                    const allViews = Object.keys(data.unwarped_images);

                    // Store data for toggling
                    window[`resultData${index}`] = {
                        unwarped_images: data.unwarped_images,
                        analysis_results: data.analysis_results,
                        showAll: false,
                        analyzedViews: analyzedViews,
                        allViews: allViews
                    };

                    // Initially show only analyzed images
                    html += `<div class="result-images" id="resultImages${index}">`;
                    html += renderResultImages(index, data.unwarped_images, data.analysis_results, analyzedViews);
                    html += '</div>';

                    // Update image count
                    setTimeout(() => {
                        const countEl = document.getElementById(`imageCount${index}`);
                        if (countEl) {
                            countEl.textContent = `Showing ${analyzedViews.length} analyzed of ${allViews.length} total`;
                        }
                    }, 10);
                }

                body.innerHTML = html || '<div style="color: #888;">No detailed data available</div>';
            } catch (error) {
                body.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
            }
        }

        function renderResultImages(index, unwarpedImages, analysisResults, viewsToShow) {
            let html = '';

            for (const direction of viewsToShow) {
                const imageData = unwarpedImages[direction];
                const analysis = analysisResults[direction];
                const hasAnalysis = analysis && Object.keys(analysis).length > 0;

                if (!imageData) continue;

                html += `
                    <div class="result-image-item">
                        <div class="direction" style="padding: 10px 15px; background: #1a4a8a; font-weight: 500;">${direction}</div>
                        ${imageData.exists && imageData.url ?
                            `<img src="${imageData.url}" alt="${direction}" onclick="openFullscreen('${imageData.url}', '${direction}')" style="cursor: zoom-in;">` :
                            '<div style="padding: 40px; text-align: center; color: #666;">Image not available</div>'
                        }
                        ${hasAnalysis ? `
                            <div class="analysis">
                                ${analysis.mood ? `
                                    <div class="analysis-field">
                                        <div class="label">Mood</div>
                                        <div class="value">${analysis.mood}</div>
                                    </div>
                                ` : ''}
                                ${typeof analysis.number_of_people !== 'undefined' ? `
                                    <div class="analysis-field">
                                        <div class="label">People</div>
                                        <div class="value">${analysis.number_of_people}</div>
                                    </div>
                                ` : ''}
                                ${analysis.description ? `
                                    <div class="analysis-field">
                                        <div class="label">Description</div>
                                        <div class="value">${analysis.description}</div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : '<div style="padding: 15px; color: #666; font-style: italic;">No analysis for this view</div>'}
                    </div>
                `;
            }

            return html;
        }

        function toggleShowAllImages(index) {
            const resultData = window[`resultData${index}`];
            if (!resultData) return;

            resultData.showAll = !resultData.showAll;

            const viewsToShow = resultData.showAll ? resultData.allViews : resultData.analyzedViews;
            const imagesContainer = document.getElementById(`resultImages${index}`);
            const showAllBtn = document.getElementById(`showAllBtn${index}`);
            const countEl = document.getElementById(`imageCount${index}`);

            if (imagesContainer) {
                imagesContainer.innerHTML = renderResultImages(
                    index,
                    resultData.unwarped_images,
                    resultData.analysis_results,
                    viewsToShow
                );
            }

            if (showAllBtn) {
                showAllBtn.textContent = resultData.showAll ? 'Show Analyzed Only' : 'Show All Images';
            }

            if (countEl) {
                countEl.textContent = resultData.showAll
                    ? `Showing all ${resultData.allViews.length} images`
                    : `Showing ${resultData.analyzedViews.length} analyzed of ${resultData.allViews.length} total`;
            }
        }

        function togglePromptExpand(index) {
            const promptBox = document.getElementById(`promptBox${index}`);
            if (!promptBox) return;

            if (promptBox.style.maxHeight === 'none') {
                promptBox.style.maxHeight = '150px';
            } else {
                promptBox.style.maxHeight = 'none';
            }
        }

        function toggleAnalysisExpand(index) {
            const analysisBox = document.getElementById(`analysisBox${index}`);
            if (!analysisBox) return;

            if (analysisBox.style.maxHeight === 'none') {
                analysisBox.style.maxHeight = '200px';
            } else {
                analysisBox.style.maxHeight = 'none';
            }
        }

        function downloadResultJson(index, filename) {
            const data = window[`resultJsonData${index}`];
            if (!data) return;

            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('unwarpedModal');
            const fullscreen = document.getElementById('fullscreenViewer');

            if (e.key === 'Escape') {
                // Close fullscreen first if it's open, otherwise close modal
                if (fullscreen.classList.contains('show')) {
                    closeFullscreen();
                } else {
                    closeModal();
                }
            }

            // Navigation with arrow keys in fullscreen mode
            if (fullscreen.classList.contains('show')) {
                if (e.key === 'ArrowLeft') {
                    navigateFullscreen(-1);
                } else if (e.key === 'ArrowRight') {
                    navigateFullscreen(1);
                }
            }
            // Navigation with arrow keys when modal is open (but fullscreen is not)
            else if (modal.classList.contains('show')) {
                if (e.key === 'ArrowLeft') {
                    navigateImage(-1);
                } else if (e.key === 'ArrowRight') {
                    navigateImage(1);
                }
            }
        });

        // Load available models for dropdown
        async function loadModels() {
            const select = document.getElementById('processModel');
            try {
                const response = await fetch('/api/models');
                if (!response.ok) throw new Error('Failed to load models');
                const data = await response.json();

                select.innerHTML = '';
                data.models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = `${model.id} - ${model.description || ''}`;
                    if (model.id === data.default) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading models:', error);
                select.innerHTML = '<option value="">Failed to load models</option>';
            }
        }

        // Prompt management
        let allPrompts = []; // Store all prompts with versions

        async function loadPrompts() {
            const nameSelect = document.getElementById('promptName');
            const versionSelect = document.getElementById('promptVersion');
            try {
                const response = await fetch('/api/prompts?all=true');
                if (!response.ok) throw new Error('Failed to load prompts');
                const data = await response.json();
                allPrompts = data.prompts || [];

                // Get unique prompt names
                const names = [...new Set(allPrompts.map(p => p.name))];

                nameSelect.innerHTML = '<option value="__new__">+ Create new prompt</option>';
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    if (name === 'default') option.selected = true;
                    nameSelect.appendChild(option);
                });

                // Load versions for selected name
                onPromptNameChange();
            } catch (error) {
                console.error('Error loading prompts:', error);
                nameSelect.innerHTML = '<option value="__new__">+ Create new prompt</option>';
                versionSelect.innerHTML = '<option value="">-</option>';
                updateSaveButton();
            }
        }

        function onPromptNameChange() {
            const nameSelect = document.getElementById('promptName');
            const versionSelect = document.getElementById('promptVersion');
            const newPromptRow = document.getElementById('newPromptRow');
            const name = nameSelect.value;

            // Show/hide new prompt name input
            if (name === '__new__') {
                newPromptRow.style.display = 'block';
                versionSelect.innerHTML = '<option value="">-</option>';
                document.getElementById('processPrompt').value = '';
                document.getElementById('newPromptName').value = '';
                updateSaveButton();
                return;
            } else {
                newPromptRow.style.display = 'none';
            }

            // Get versions for this name
            const versions = allPrompts
                .filter(p => p.name === name)
                .map(p => p.version)
                .sort((a, b) => b - a); // Descending (latest first)

            versionSelect.innerHTML = '';
            versions.forEach((v, i) => {
                const option = document.createElement('option');
                option.value = v;
                option.textContent = `v${v}${i === 0 ? ' (latest)' : ''}`;
                versionSelect.appendChild(option);
            });

            // Load the latest version content
            onPromptVersionChange();
            updateSaveButton();
        }

        async function onPromptVersionChange() {
            const name = document.getElementById('promptName').value;
            const version = document.getElementById('promptVersion').value;
            const textarea = document.getElementById('processPrompt');

            if (!name || name === '__new__' || version === '') return;

            try {
                const response = await fetch(`/api/prompts/${name}/${version}`);
                if (!response.ok) throw new Error('Failed to load prompt');
                const data = await response.json();
                textarea.value = data.content || '';
            } catch (error) {
                console.error('Error loading prompt version:', error);
            }
        }

        function updateSaveButton() {
            const nameSelect = document.getElementById('promptName');
            const btn = document.getElementById('savePromptBtn');
            const name = nameSelect.value;

            if (name === '__new__') {
                btn.textContent = 'Create v0';
            } else {
                // Find next version number
                const versions = allPrompts
                    .filter(p => p.name === name)
                    .map(p => p.version);
                const nextVersion = versions.length > 0 ? Math.max(...versions) + 1 : 0;
                btn.textContent = `Push v${nextVersion}`;
            }
        }

        async function savePrompt() {
            const nameSelect = document.getElementById('promptName');
            const content = document.getElementById('processPrompt').value.trim();

            if (!content) {
                alert('Prompt content cannot be empty');
                return;
            }

            let promptName;
            if (nameSelect.value === '__new__') {
                promptName = document.getElementById('newPromptName').value.trim();
                if (!promptName) {
                    alert('Please enter a name for the new prompt');
                    document.getElementById('newPromptName').focus();
                    return;
                }
            } else {
                promptName = nameSelect.value;
            }

            try {
                const response = await fetch('/api/prompts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: promptName, content })
                });

                if (!response.ok) throw new Error('Failed to save prompt');
                const data = await response.json();

                alert(`Prompt ${data.action}: ${data.name} v${data.version}`);

                // Reload prompts and select the saved one
                await loadPrompts();
                document.getElementById('promptName').value = data.name;
                onPromptNameChange();
                document.getElementById('promptVersion').value = data.version;
            } catch (error) {
                console.error('Error saving prompt:', error);
                alert('Failed to save prompt: ' + error.message);
            }
        }

        // Initialize
        loadStats();
        loadModels();
        loadPrompts();
    </script>
</body>
</html>
